# pa2 = mean( (predict(TODO)>0.5) == lego_te$Amazon_Higher )  # TODO
# pa3 = mean( (predict(TODO)>0.5) == lego_te$Amazon_Higher )  # TODO
### --------------
### END SOLUTION
# paste("Model 1: ", round(pa1,3))
# paste("Model 2: ", round(pa2,3))
# paste("Model 3: ", round(pa3,3))
#| context: output
# Generate data
set.seed(1)
n = 200
categories = rnorm(4, sd=1)
x2 = sample(categories, n, replace=TRUE)
x1 = rnorm(n, mean=2*x2, sd=0.5)
y = rnorm(n, mean=x1-3*x2, sd=0.1)
plot(x1, y, pch=19, main=paste("Cor(x1,y) =",round(cor(x1,y),3)))
#| context: output
# Generate data
set.seed(1)
n = 200
categories = rnorm(4, sd=1)
x2 = sample(categories, n, replace=TRUE)
x1 = rnorm(n, mean=2*x2, sd=0.5)
y = rnorm(n, mean=x1-3*x2, sd=0.1)
# Create plot
cols = x2
for (i in 1:4) {
cols[cols==categories[i]] = i
}
plot(x1, y, col=cols, pch=19, main=paste("Cor(x1,y) =",round(cor(x1,y),3)))
legend(x=2.5,y=2, c("1","2","3","4"), fill=unique(cols), title="x2", ncol=2)
# Compute the partial correlation
y_reg = lm(y~x2)
x1_reg = lm(x1~x2)
plot(x1_reg$residuals, y_reg$residuals, xlab="x1~x2 residual", ylab="y~x2 residual",
main=paste("Partial correlation:", round(cor(y_reg$residuals,x1_reg$residuals),3)))
ice_url = url("https://ubc-stat.github.io/stat-306-student/lecture-data/arctic_sea_ice.csv")
ice = na.omit(read.csv(ice_url, header=T, sep=","))
y = ice$extent
x = ice$year
# Create a scatterplot
plot(x, y, xlab="Year", ylab="Extent (millions sq. km)")
# Fit a linear model
reg = NULL  # TODO
# In case you want to do any calculations
# TODO
# Fit the quadratic model
quad_reg = lm(y~x+I(x^2))
summary(quad_reg)
head(ice, 10)
ice_url = url("https://ubc-stat.github.io/stat-306-student/lecture-data/arctic_sea_ice.csv")
ice = na.omit(read.csv(ice_url, header=T, sep=","))
y = ice$extent
x = ice$year
head(ice, 10)
# Create a scatterplot
plot(x, y, xlab="Year", ylab="Extent (millions sq. km)")
# Fit a linear model
reg = lm(y~x)  # TODO
summary(reg)
# In case you want to do any calculations
# TODO
new = data.frame(x = 1988)
predict(reg, new, se.fit=TRUE, interval="prediction", level=0.95)
new_2 = data.frame(x = 2025)
predict(reg, new_2, se.fit=TRUE, interval="prediction", level=0.95)
# Fit a linear model
reg = lm(y~x)  # TODO
summary(reg)
# Residuals against fitted sea level values
plot(reg$fitted.values, reg$residuals, xlab="Fitted Values", ylab="Residuals")
# Residuals against year
plot(x, reg$residuals, xlab="Year", ylab="Residuals")
# Normal QQ plot
qqnorm(reg$residuals)
qqline(reg$residuals)
### START SOLUTION
### --------------
# Fit the new model
reg2 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
summary(reg2) # If mentioned, generally include regular value as well
# Create the residual plot
# TODO
plot(reg2$fitted.values, reg2$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg2$fitted.values, reg2$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# TODO
# Fit the linear model
diamonds$Col <- relevel(factor(diamonds$Col), ref = "I")
diamonds$Cla <- relevel(factor(diamonds$Cla), ref = "VS2")
diamonds$Cer <- relevel(factor(diamonds$Cer), ref = "GIA")
reg1 = lm(log(diamonds$P)~diamonds$Car+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
summary(reg1)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the residual plot
# TODO
plot(reg1$fitted.values, reg1$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg1$fitted.values, reg1$residuals), col = "blue", lwd = 2)
# qqnorm(reg1$residuals)
# qqline(reg1$residuals)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the new model
reg2 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
summary(reg2)
# Create the residual plot
# TODO
plot(reg2$fitted.values, reg2$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg2$fitted.values, reg2$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the model without certification body
reg3 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla)  # TODO
summary(reg3)
# Create the residual plot
# TODO
plot(reg3$fitted.values, reg3$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg3$fitted.values, reg3$residuals), col = "blue", lwd = 2)
# qqnorm(reg3$residuals)
# qqline(reg3$residuals)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the model without certification body
reg3 = lm(log(diamonds$P)~I(diamonds$Car^2)+diamonds$Col+diamonds$Cla)  # TODO
# reg3 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla)  # TODO
summary(reg3)
# Create the residual plot
# TODO
plot(reg3$fitted.values, reg3$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg3$fitted.values, reg3$residuals), col = "blue", lwd = 2)
# qqnorm(reg3$residuals)
# qqline(reg3$residuals)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the new model
reg2 = lm(log(diamonds$P)~I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
# reg2 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
summary(reg2)
# Create the residual plot
# TODO
plot(reg2$fitted.values, reg2$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg2$fitted.values, reg2$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the residual plot
# TODO
plot(reg1$fitted.values, reg1$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg1$fitted.values, reg1$residuals), col = "blue", lwd = 2)
# qqnorm(reg1$residuals)
# qqline(reg1$residuals)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# TODO
# Fit the linear model
diamonds$Col <- relevel(factor(diamonds$Col), ref = "I")
diamonds$Cla <- relevel(factor(diamonds$Cla), ref = "VS2")
diamonds$Cer <- relevel(factor(diamonds$Cer), ref = "GIA")
reg1 = lm(log(diamonds$P)~diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
# reg1 = lm(log(diamonds$P)~diamonds$Car+diamonds$Col+diamonds$Cla+diamonds$Cer)
summary(reg1)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the residual plot
# TODO
plot(reg1$fitted.values, reg1$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg1$fitted.values, reg1$residuals), col = "blue", lwd = 2)
# qqnorm(reg1$residuals)
# qqline(reg1$residuals)
### --------------
### END SOLUTION
library(dplyr)
library(tidyverse)
library(ggplot2)
# install.packages("fastDummies")
library(fastDummies)
# install.packages('stringi')
cancer = read.csv("METABRIC_RNA_Mutation.csv", header=TRUE)[,1:31]
cancer
summary(cancer)
cancer_new <- cancer %>%
filter(!is.na(age_at_diagnosis), !is.na(type_of_breast_surgery), !is.na(tumor_size), !is.na(tumor_stage), !is.na(chemotherapy), !is.na(hormone_therapy), !is.na(radio_therapy), !is.na(overall_survival_months), cancer_type_detailed == "Breast Invasive Ductal Carcinoma", overall_survival == 1) %>%
select(age_at_diagnosis, type_of_breast_surgery, tumor_stage, chemotherapy, hormone_therapy, radio_therapy, overall_survival_months)
cancer_new
boxplot(tumor_size~tumor_stage, data=cancer)
fullmod = lm(overall_survival_months ~ .*.,data=cancer_new_2)
setwd("~/Documents – SNG058/Canada - UBC/2024 Term 1/STAT 306/Webwork and Homework")
# Q1
gaittable = read.table(file = "GaitSpeed_NE8JGB0PK705.txt", header = TRUE, sep = "")
gaittable
gait = gaittable$GaitSpeed
res = gaittable$ResVO2
age = gaittable$Age
plot(res, gait)
plot(age, gait)
reg = lm(gait ~ res + age)
summary(reg)
# Standardised residuals
resids = rstandard(reg)
max(abs(resids)) # 2.297704
X = cbind(1, res, age)
P = X %*% solve(t(X)%*%X, t(X))
P_diag = diag(P)
typeof(P_diag)
max(abs(P_diag)) # 0.1684193
hat1 <- hatvalues(reg)
max(hat1)
get_position_of_max <- function(values) {
if (length(values) == 0) {
return(NA)  # Return NA if the vector is empty
}
return(which.max(values))
}
# Example usage
position <- get_position_of_max(abs(P_diag))
cat("The position of the maximum value is:", position, "\n")
res[32] # 25.63
age[32] # 63.59
exp_gait = 1.959375 + 0.048757 * res[32] + -0.020844 * age[32]
exp_gait # 1.883547
age[hat1==max(hat1)]
res[hat1==max(hat1)]
reg$fit[hat1==max(hat1)]
setwd("~/Documents – SNG058/Canada - UBC/2024 Term 1/STAT 306/STAT-306-Project-Group-10")
library(dplyr)
library(tidyverse)
library(ggplot2)
# install.packages("fastDummies")
library(fastDummies)
# install.packages('stringi')
cancer = read.csv("METABRIC_RNA_Mutation.csv", header=TRUE)[,1:31]
cancer
summary(cancer)
cancer_new <- cancer %>%
filter(!is.na(age_at_diagnosis), !is.na(type_of_breast_surgery), !is.na(tumor_size), !is.na(tumor_stage), !is.na(chemotherapy), !is.na(hormone_therapy), !is.na(radio_therapy), !is.na(overall_survival_months), cancer_type_detailed == "Breast Invasive Ductal Carcinoma", overall_survival == 1) %>%
select(age_at_diagnosis, type_of_breast_surgery, tumor_stage, chemotherapy, hormone_therapy, radio_therapy, overall_survival_months)
cancer_new
fullmod = lm(overall_survival_months ~ .*.,data=cancer_new_2)
fullmod = lm(overall_survival_months ~ .*.,data=cancer_new)
step(fullmod, direction = "both")
# Load the data
diamonds = read.table("Diamonds.txt", header=T)
### START SOLUTION
### --------------
# Create the scatterplot
# TODO
plot(diamonds$Car, diamonds$P, xlab="Caratage", ylab="Price")
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the plots
# TODO
# 1.
# plot(diamonds$Col, diamonds$P, xlab="Colour Purity", ylab="Price")
boxplot(P~Col, data=diamonds)
# 2.
# plot(diamonds$Cla, diamonds$P, xlab="Clarity", ylab="Price")
boxplot(P~Cla, data=diamonds)
# 3.
# plot(diamonds$Cer, diamonds$P, xlab="Certification Body", ylab="Price")
boxplot(P~Cer, data=diamonds)
### --------------
### END SOLUTION
# Delete this code block if not used
library(dplyr)
tb1 <- diamonds %>% group_by(Cla) %>%
summarise(total_count = n(), mean = mean(P), median = median(P), .groups = 'drop')
tb1
# tb2 <- diamonds %>% group_by(Col) %>%
#   summarise(total_count=n(), .groups = 'drop')
# tb2
### START SOLUTION
### --------------
# TODO
# Fit the linear model
diamonds$Col <- relevel(factor(diamonds$Col), ref = "I")
diamonds$Cla <- relevel(factor(diamonds$Cla), ref = "VS2")
diamonds$Cer <- relevel(factor(diamonds$Cer), ref = "GIA")
# reg1 = lm(log(diamonds$P)~diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
reg1 = lm(log(diamonds$P)~diamonds$Car+diamonds$Col+diamonds$Cla+diamonds$Cer)
summary(reg1)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the residual plot
# TODO
plot(reg1$fitted.values, reg1$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg1$fitted.values, reg1$residuals), col = "blue", lwd = 2)
# qqnorm(reg1$residuals)
# qqline(reg1$residuals)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the new model
# reg2 = lm(log(diamonds$P)~I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
reg2 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla+diamonds$Cer)  # TODO
summary(reg2)
# Create the residual plot
# TODO
plot(reg2$fitted.values, reg2$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg2$fitted.values, reg2$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the model without certification body
# reg3 = lm(log(diamonds$P)~I(diamonds$Car^2)+diamonds$Col+diamonds$Cla)  # TODO
reg3 = lm(log(diamonds$P)~diamonds$Car+I(diamonds$Car^2)+diamonds$Col+diamonds$Cla)  # TODO
summary(reg3)
# Create the residual plot
# TODO
plot(reg3$fitted.values, reg3$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(reg3$fitted.values, reg3$residuals), col = "blue", lwd = 2)
# qqnorm(reg3$residuals)
# qqline(reg3$residuals)
### --------------
### END SOLUTION
# Read the data
dex = read.table("Dexterity.txt", header=TRUE)
### START SOLUTION
### --------------
library(car)
# Create the speed variable
# TODO
dex$Speed = 1/dex$Time
# head(dex, 10)
dex = subset(dex, select = -c(Time))
# head(dex, 10)
# Create the plots
# TODO
reg_1 = lm(dex$Speed~dex$Age*dex$Dominant)  # TODO
summary(reg_1)
scatterplot(Speed~Age*Dominant, data=dex, smooth=FALSE)
reg_2 = lm(dex$Speed~dex$Age*dex$Sex)  # TODO
summary(reg_2)
scatterplot(Speed~Age*Sex, data=dex, smooth=FALSE)
### --------------
### END SOLUTION
# Create a list of models
models = list() # Empty list to start
### START SOLUTION
### --------------
# Perform backward selection
# Fit the full model
full_model = lm(Speed ~ Age + Dominant + Sex + HD + HU + Age:Dominant,data=dex)
# models[[1]] = lm(Speed ~ .*.,data=dex)  # TODO
models[[1]] = lm(Speed ~ Age + Dominant + Sex + HD + HU + Age:Dominant,data=dex)  # TODO
summary(models[[1]])
# Fit the next model in the backward selection procedure
models[[2]] = lm(Speed ~ Age + Dominant + HD + HU + Age:Dominant,data=dex)  # TODO
summary(models[[2]])
# Continue...
# TODO
models[[3]] = lm(Speed ~ Age + Dominant + HD + HU,data=dex)  # TODO
summary(models[[3]])
# TODO
models[[4]] = lm(Speed ~ Age + Dominant + HU,data=dex)  # TODO
summary(models[[4]])
# TODO
models[[5]] = lm(Speed ~ Age + Dominant,data=dex)  # TODO
summary(models[[5]])
# Print the final model
summary(models[[5]])
# backwards = step(fullmod)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Compute Mallows' Cp
# TODO
n = nrow(dex) # 174
full_model = lm(Speed ~ Age + Dominant + Sex + HD + HU + Age:Dominant,data=dex)
Cp = function(model, full_model) {
p = length(coef(model))-1
SSR_p = summary(model)$sigma * (n-(p+1))
MSR_q = summary(full_model)$sigma
return(SSR_p/MSR_q - (n - 2*(p+1)))
}
models_cp = c()
for (m in models) {
models_cp = append(models_cp, Cp(m, full_model))
}
# models_cp
# Create the Cp plot
# TODO
# grid(1:length(models_cp),models_cp)
plot(1:length(models_cp), models_cp, xlab="p", ylab="Cp")
abline(a=1, b=1)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the residual plots
# TODO
plot(models[[5]]$fitted.values, models[[5]]$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(models[[5]]$fitted.values, models[[5]]$residuals), col = "blue", lwd = 2)
plot(models[[4]]$fitted.values, models[[4]]$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(models[[4]]$fitted.values, models[[4]]$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the model with completion time as the response
dex1 = read.table("Dexterity.txt", header=TRUE)
mod6 = lm(Time ~ Age + Dominant,data=dex1)  # TODO
# Create the residual plot
# TODO
plot(mod6$fitted.values, mod6$residuals, xlab="Fitted Values", ylab="Residuals")
abline(a = 0, b = 0)
lines(lowess(mod6$fitted.values, mod6$residuals), col = "blue", lwd = 2)
### --------------
### END SOLUTION
# Read the data
lego = read.csv("lego.csv", header=TRUE)
# lego
### START SOLUTION
### --------------
# Construct the response variable
lego$Amazon_Higher = (lego$Amazon_Price > lego$Price)  # TODO
# lego
# Use table() to summarize the data
# TODO
tb2 <- lego %>% group_by(Amazon_Higher) %>%
summarise(total_count = n(), .groups = 'drop')
tb2
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Create the plots and tables
# TODO
boxplot(Pieces ~ Amazon_Higher, data=lego)
boxplot(Unique_Pieces ~ Amazon_Higher, data=lego)
boxplot(Year ~ Amazon_Higher, data=lego)
# INSERT SET THEME HERE
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Fit the logistic model
lreg = NULL  # TODO
summary(lreg)
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Predict the probability for the new set
# TODO
### --------------
### END SOLUTION
# Compute the correlation between number of pieces and unique pieces
cor(lego$Pieces, lego$Unique_Pieces)
# Set the seed for reproducibility
set.seed(306)  # TODO: change the seed
# Split the data
n = nrow(lego)
test_inds = sample(n, size=100, replace=FALSE)
lego_te = lego[test_inds,]
lego_tr = lego[-test_inds,]
### START SOLUTION
### --------------
# Fit models on the training set
# TODO
### --------------
### END SOLUTION
### START SOLUTION
### --------------
# Compute the prediction accuracy on the test set for each model
# Hint: check the "type" argument of the predict.glm() function
# pa1 = mean( (predict(TODO)>0.5) == lego_te$Amazon_Higher )  # TODO
# pa2 = mean( (predict(TODO)>0.5) == lego_te$Amazon_Higher )  # TODO
# pa3 = mean( (predict(TODO)>0.5) == lego_te$Amazon_Higher )  # TODO
### --------------
### END SOLUTION
# paste("Model 1: ", round(pa1,3))
# paste("Model 2: ", round(pa2,3))
# paste("Model 3: ", round(pa3,3))
